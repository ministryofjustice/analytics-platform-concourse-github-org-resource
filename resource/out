#!/usr/bin/env python

import os
import re
import subprocess
import json

from moj_analytics.concourse import Resource
import requests
import yaml

from common import get_all, get_org, github_api_request, pushed_at


fly = '/usr/local/bin/fly'

INVALID_CHARS = re.compile(r'[^-a-z0-9]')
SURROUNDING_HYPHENS = re.compile(r'^-*|-*$')


class ansi:
    green = '\x1b[92m'
    grey = '\x1b[90m'
    reset = '\x1b[0m'


@Resource
def create_pipelines(src_dir, source={}, params={}):
    print('Logging in to Concourse')
    get_fly(**source)
    fly_login(**source)

    print('Fetching existing pipelines', flush=True)
    pipelines = get_pipelines(**source)
    print(f'Found {len(pipelines)} pipelines', flush=True)

    print(f'Fetching {source["name"]} org', flush=True)
    org = get_org(**source)

    print('Fetching org repos', flush=True)
    repos = get_all(org['repos_url'], **source)

    for repo in repos:
        if repo['name'] in pipelines:
            print(
                f'Pipeline exists for {repo["name"]}',
                flush=True)
            continue

        if buildfile_exists(repo, **source):
            print(
                (
                    f'{ansi.green}Creating pipeline for '
                    f'{repo["name"]}{ansi.reset}'
                ),
                flush=True)

            pipeline_type = buildfile_type(repo, **source)

            fly_set_pipeline(repo, pipeline_type=pipeline_type, **source)

        else:
            print(
                f'{ansi.grey}No buildfile for {repo["name"]}{ansi.reset}',
                flush=True)

    timestamps = sorted(set(map(pushed_at, repos)))

    return {'version': {'ref': str(timestamps[-1])}}


def get_pipelines(concourse_url, team_name, **kwargs):
    with open('/root/.flyrc') as f:
        fly_config = yaml.load(f.read())
    token = fly_config['targets']['default']['token']['value']

    url = f'{concourse_url}/api/v1/teams/{team_name}/pipelines'
    headers = {
        'Cookie': f'ATC-Authorization="Bearer {token}"',
    }
    pipelines = requests.get(url, headers=headers).json()
    return [p['name'] for p in pipelines]


def buildfile_exists(repo, **kwargs):
    url = repo['contents_url'].replace('{+path}', 'deploy.json')
    return github_api_request(url, **kwargs).status_code != 404


def buildfile_type(repo, **kwargs):
    url = repo['contents_url'].replace('{+path}', 'deploy.json')
    metadata = github_api_request(url, **kwargs).json()
    download_url = metadata['download_url']
    deploy_type = 'webapp'
    try:
        deploy_file = github_api_request(download_url, **kwargs).json()
        deploy_type = deploy_file.get('type', 'webapp')
    except json.decoder.JSONDecodeError:  # handle malformed deploy.json
        # if json is malformed just assume it's a webapp deploy
        pass
    return deploy_type


def get_fly(concourse_url, **kwargs):
    url = f'{concourse_url}/api/v1/cli?arch=amd64&platform=linux'
    response = requests.get(url, stream=True)
    if response.status_code == 200:
        with open(fly, 'wb') as f:
            for chunk in response:
                f.write(chunk)
        os.chmod(fly, 0o755)  # make executable


def fly_login(concourse_url, username, password, team_name, **source):
    subprocess.run(
        [
            fly, '-t', 'default', 'login',
            '-c', concourse_url,
            '-u', username,
            '-p', password,
            '-n', team_name
        ],
        stdout=subprocess.PIPE,
        check=True)


def fly_set_pipeline(repo, team_name, pipeline_type='webapp', **kwargs):
    app_name = normalize(repo['name'])
    subprocess.run(
        [
            fly, '-t', 'default', 'set-pipeline',
            '-p', repo["name"],
            '-c', f'/opt/resource/{pipeline_type}_pipeline.yaml',
            '-v', f'app-name={app_name}',
            '-v', f'github-org={kwargs["name"]}',
            '-v', f'github-repo={repo["name"]}',
            '-n'

        ],
        stdout=subprocess.PIPE,
        check=True)


def normalize(name):
    name = name.lower()
    name = SURROUNDING_HYPHENS.sub('', INVALID_CHARS.sub('-', name))
    return name[:50]


if __name__ == '__main__':
    create_pipelines()
