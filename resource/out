#!/usr/bin/env python

from base64 import b64decode
import os
import subprocess

from moj_analytics.concourse import Resource
import requests
import yaml

from common import get_all, get_org, github_api_request, pushed_at


fly = '/usr/local/bin/fly'


class ansi:
    green = '\x1b[92m'
    grey = '\x1b[90m'
    reset = '\x1b[0m'


@Resource
def create_pipelines(src_dir, source={}, params={}):
    print('Logging in to Concourse')
    get_fly(**source)
    fly_login(**source)

    print('Fetching existing pipelines', flush=True)
    pipelines = get_pipelines(**source)
    print(f'Found {len(pipelines)} pipelines', flush=True)

    print(f'Fetching {source["name"]} org', flush=True)
    org = get_org(**source)

    print('Fetching org repos', flush=True)
    repos = get_all(org['repos_url'], **source)

    for repo in repos:
        if repo['name'] in pipelines:
            print(
                f'Pipeline exists for {repo["name"]}',
                flush=True)
            continue

        if buildfile_exists(repo, **source):
            print(
                (
                    f'{ansi.green}Creating pipeline for '
                    f'{repo["name"]}{ansi.reset}'
                ),
                flush=True)
            fly_set_pipeline(repo, **source)

        else:
            print(
                f'{ansi.grey}No buildfile for {repo["name"]}{ansi.reset}',
                flush=True)

    timestamps = sorted(set(map(pushed_at, repos)))

    return {'version': {'ref': str(timestamps[-1])}}


def get_pipelines(concourse_url, team_name, **kwargs):
    with open('/root/.flyrc') as f:
        fly_config = yaml.load(f.read())
    token = fly_config['targets']['default']['token']['value']

    url = f'{concourse_url}/api/v1/teams/{team_name}/pipelines'
    headers = {
        'Cookie': f'ATC-Authorization="Bearer {token}"',
    }
    pipelines = requests.get(url, headers=headers).json()
    return [p['name'] for p in pipelines]


def buildfile_exists(repo, **kwargs):
    url = repo['contents_url'].replace('{+path}', 'Jenkinsfile')
    return github_api_request(url, **kwargs).status_code != 404


def get_fly(concourse_url, **kwargs):
    url = f'{concourse_url}/api/v1/cli?arch=amd64&platform=linux'
    response = requests.get(url, stream=True)
    if response.status_code == 200:
        with open(fly, 'wb') as f:
            for chunk in response:
                f.write(chunk)
        os.chmod(fly, 0o755)  # make executable


def fly_login(concourse_url, username, password, team_name, **source):
    subprocess.run(
        [
            fly, '-t', 'default', 'login',
            '-c', concourse_url,
            '-u', username,
            '-p', password,
            '-n', team_name
        ],
        stdout=subprocess.PIPE,
        check=True)


def fly_set_pipeline(repo, team_name, **kwargs):
    subprocess.run(
        [
            fly, '-t', 'default', 'set-pipeline',
            '-p', repo["name"],
            '-c', '/opt/resource/pipeline.yaml',
            '-n', team_name,
            '-v', f'app-name={repo["name"]}',
            '-v', f'github-access-token={kwargs["access_token"]}',
            '-v', f'github-org={kwargs["name"]}',
            '-v', f'cookie-secret={kwargs["cookie-secret"]}',
            '-v', f'cluster-ca={kwargs["cluster-ca"]}',
            '-v', f'token={kwargs["token"]}'
        ],
        stdout=subprocess.PIPE,
        check=True)


if __name__ == '__main__':
    create_pipelines()
